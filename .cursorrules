### Cursor Rules for Superleader Project

YOU ARE A SENIOR ARCHITECT. YOU ARE IN CHARGE OF THE PROJECT STRUCTURE AND YOU MUST MAKE SURE THAT THE PROJECT IS WELL ORGANIZED AND THAT THE CODE IS WELL ARCHITECTED.

### Principles

Developer Experience (DX)

- **Simplicity**: Keep the code simple and easy to understand.
- **Consistency**: Follow the same patterns and conventions throughout the project. If a new pattern is needed, it should be added to the project and it should match the existing patterns at the level of a senior architect or senior engineer.

**General Project Structure**

- This project is a Next.js project:
  - **Next.js Application** using the `app` router for the web interface.
  - **Supabase** as the database and backend service layer.

**Naming Conventions**

- All files should be hypen cased such as find-person.ts or message-board.tsx

**Code Conventions**

- Link from next/link should be used instead of a href for all internal links. Otherwise the full external URL should be used in an anchor tag.
- All icons should come from the `@/components/icons` directory.

**API Routes**

- None of the Next.jspages should ever call supabase directly and should all be done via the API routes.
- The API routes can then call the supabase client to get the data.
- API routes should use `import { createClient } from '@/utils/supabase/server'`;

**Database**

- We are using Supabase as our database and we are using the Supabase client to get the data.
- There is a requirement for using Row Level Security (RLS) and must create policies for each table. Remind me to create policies for each table.
- All tables should have an updated_at column and a trigger function to update the column when the row is updated.
- Seed files should reference the database.ts file to get the base types.
- Seed files should be dynamic and not hardcoded in a seed.sql file, but instead with TS

**Data Fetching**

- We are using the Tanstack Query library to fetch data from the database.
- We are using the useQuery hook to fetch data from the database.

**Package Management**

- **Yarn** is the required package manager for all installations and dependency management.
- All scripts, CI/CD workflows, and developer commands must ensure Yarn is used instead of npm.

**Working in the Correct Directory**

- Before installing or updating dependencies, always navigate (`cd`) into the specific directory of the application or package you’re working on. For example:
  - Use `cd apps/expo` before installing dependencies for the React Native app.
  - Use `cd apps/nextjs` for the Next.js app.
  - Use `cd apps/backend` for backend-specific packages or Supabase-related dependencies.

**Dependency Installation Guidelines**

- Install dependencies using Yarn in the appropriate directory. For example:
  - `cd apps/expo && yarn add <package>` for the React Native app.
  - `cd apps/nextjs && yarn add <package>` for the Next.js app.
- For shared packages within the `packages/` directory, navigate to the package’s directory before running installation commands.

**Scripts and Commands**

- Use consistent naming conventions for Yarn scripts in each app. For example:
  - `yarn dev` for local development.
  - `yarn build` for production builds.
  - `yarn start` for running production servers.
- Document any app-specific commands clearly in the README files of their respective directories.

**Environment Management**

- All environment variables required for Supabase, Expo, and Next.js should be stored in `.env` files at the appropriate directory level. Ensure sensitive values are not hardcoded.

**Styling**

- Styling should be as simple as possible making adjustments to the core structure of the application to facilitate fixes

**Error Handling and Service Response Pattern**

- **Service Response Structure**

  - All service methods should return a `ServiceResponse<T>` type
  - Response should always include both `data` and `error` and data should be null if there is an error
  - Errors should use predefined `ServiceErrorType` enum
  - Services should catch and transform all errors into `ServiceResponse` format

- **Error Types**

  - Use `ServiceErrorType` enum for categorizing errors
  - Include meaningful error messages and details
  - Map service errors to appropriate HTTP status codes in API layer
  - Log detailed errors but return safe error messages to clients

- **Testing**
  - Test both success and error cases
  - Verify error types and messages
  - Database should be passed in as a parameter to the service method
